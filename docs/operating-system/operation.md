# Linux 操作
## gdb 怎么用？
GDB (GNU Debugger) 是一个强大的 UNIX 系统下的程序调试工具。下面是 GDB 的基本使用方法：

1. **启动 GDB**
    使用 gdb 命令启动 GDB。例如，如果要调试一个名为 `a.out` 的程序，可以这样做：
    ```bash
    gdb a.out
    ```

2. **设置断点 (breakpoint)**
    在程序的特定位置设置断点，当程序运行到该位置时，它会暂停执行，以便你可以检查程序状态。
    ```bash
    break main             # 在 main 函数处设置断点
    break filename.c:42    # 在 filename.c 的第42行设置断点
    ```

3. **运行程序**
    ```bash
    run (或 r) [arguments]  # 运行程序，并传递参数给它 (如果有的话)
    ```

4. **程序控制**
    当程序在断点处停止时，你可以使用以下命令控制它：
    - `next (或 n)`: 单步执行，但不进入函数。
    - `step (或 s)`: 单步执行，进入函数。
    - `continue (或 c)`: 继续执行程序直到下一个断点或程序结束。
    - `finish`: 运行程序直到当前函数完成。

5. **检查程序状态**
    - `list (或 l)`: 显示当前代码的上下文。
    - `print (或 p) variable`: 打印变量的值。
    - `info locals`: 显示局部变量。
    - `info registers`: 显示寄存器内容。
    - `backtrace (或 bt)`: 显示函数调用栈。

6. **修改程序状态**
    - `set variable x=5`: 将变量 x 的值设置为 5。

7. **退出 GDB**
    ```bash
    quit (或 q)
    ```

8. **其他常用命令**
    - `info breakpoints`: 显示所有断点。
    - `delete breakpoint_number`: 删除指定编号的断点。
    - `clear filename.c:42`: 删除在 filename.c 的第42行的断点。
    - `watch variable`: 当变量的值发生变化时中断。
    - `disable breakpoint_number`: 禁用指定编号的断点，但不删除。
    - `enable breakpoint_number`: 启用之前禁用的断点。

注意，最好在编译程序时使用 `-g` 选项，这样 GDB 可以获取到更多的调试信息。

## `grep` 怎么用？
`grep`是 Linux 系统中的一个非常强大和常用的文本搜索工具，它可以用来搜索指定模式的文本行。基本语法如下：

```sh
grep [options] pattern [file...]
```  

`pattern` 是你要搜索的字符串或正则表达式。  

`file` 是你要搜索的文件。如果省略文件名，`grep` 将从标准输入读取。例如，`cat filename | grep "search_string"`  

1. **基本用法**

    在文件中搜索字符串：

    ```sh
    grep "search_string" filename
    ```

2. **忽略大小写**

    使用 `-i` 选项来忽略大小写：

    ```sh
    grep -i "search_string" filename
    ```

3. **递归搜索**

    使用 `-r` 或 `-R` 选项在目录及其子目录中递归搜索：

    ```sh
    grep -r "search_string" directory
    ```

## `awk` 怎么用？
`awk` 是一个强大的文本处理工具，它主要用于在文本文件中查找并处理模式，对数据进行抽取和报告生成。它使用自己的编程语言，并具有流程控制、变量、条件和迭代等编程构造。

基本语法为：
```bash
awk 'pattern { action }' file
```

其中，`pattern` 是要匹配的模式，`action` 是匹配后要执行的操作，`file` 是要处理的文件名。

1. **打印文件的内容**（类似于 `cat` 命令）：

    ```bash
    awk '{ print }' filename
    ```

2. **打印文件的某列**：

    默认情况下，`awk` 使用空格作为字段分隔符。例如，要打印 `/etc/passwd` 文件的第一个和第三字段：

    ```bash
    awk -F: '{ print $1,$3 }' /etc/passwd
    ```

    `-F` 选项用于指定字段分隔符，这里是冒号。

3. **条件打印**：

    打印所有第一字段为 `root` 的行：

    ```bash
    awk '$1=="root" { print }' /etc/passwd
    ```

4. **内置变量**：

     - `NR`：代表当前的行号。
     - `NF`：代表当前行的字段数。
     - `$0`：代表整行内容。

     打印最后一行：

     ```bash
     awk 'END { print }' filename
     ```

5. **使用多个命令**：

    打印 `/etc/passwd` 中的用户和他们的 shell：

    ```bash
    awk -F: '{ print "User:", $1, "Shell:", $7 }' /etc/passwd
    ```

6. **算术运算**：

    假设有一个文件 `file.txt`，其内容为两列数字。要打印每行数字的总和：

    ```bash
    awk '{ print $1 + $2 }' file.txt
    ```

## 如何查看连接的端口号？
如果你想查看在你的系统上哪些端口号被使用（即哪些端口正在监听或建立的连接），你可以使用多种方法，具体取决于你的操作系统。以下是一些常见的方法：

1. **使用 `netstat` 命令**
```bash
netstat -tuln   # 显示所有正在监听的 TCP/UDP 端口
```

2. **使用 `lsof` 命令**
```bash
lsof -i        # 显示所有网络连接
lsof -i :22    # 查找特定端口（例如端口22）的连接
```

3. **使用 `ss` 命令** (`ss` 是现代 Linux 系统上 `netstat` 的替代品)
```bash
ss -tuln       # 显示所有正在监听的 TCP/UDP 端口
```

## `/proc` 文件夹是什么
在 Linux 系统中，`/proc` 是一个特殊的虚拟文件系统，用于内核与用户空间进程的通信。它不是一个实际的文件系统，如 ext4 或 xfs，而是一个运行时的文件系统，所以它不占用磁盘空间。其内容是在内存中动态生成的。

`/proc` 包含了许多关于系统状态的信息，其中大部分是关于正在运行的进程的信息。这些信息以文件和目录的形式表示，可以通过常规的文件读取命令（如 `cat` 和 `less`）来访问。

以下是 `/proc` 中的一些常见条目及其描述：

1. **进程目录**：对于每个进程，`/proc` 都有一个以进程 ID 命名的目录。这些目录包含了关于各个进程的信息。 例如：`/proc/1/` 是 PID 为 1 的进程（通常是 init 或 systemd）的目录。

2. **`/proc/cpuinfo`**：包含了关于系统 CPU 的详细信息。

3. **`/proc/meminfo`**：显示了系统内存的使用情况。

4. **`/proc/version`**：显示了正在运行的 Linux 版本信息。

5. **`/proc/filesystems`**：列出了系统所支持的文件系统类型。

6. **`/proc/mounts`**：列出了当前的挂载点。

7. **`/proc/net/`**：包含了与网络相关的各种信息。

8. **`/proc/sys/`**：包含了可以改变的内核参数。例如，通过 sysctl 命令可以修改这些参数。

由于 `/proc` 提供了丰富的信息和配置接口，它被许多系统工具和命令用于查询和设置系统状态。例如，`ps`、`top` 和许多其他系统监视工具都依赖 `/proc` 中的信息来工作。

## 如何查看 IO 利用率？
在 Linux 系统上，有多种工具可以用来查看 I/O 利用率和其他相关的性能指标。

1. **iostat**

    `iostat` 是 `sysstat` 包的一部分，它可以提供 CPU 统计信息和输入/输出统计信息。要查看所有磁盘的 I/O 统计信息，可以使用：

    ```bash
    iostat -dx 1
    ```

    这个命令每秒刷新一次 I/O 统计信息。你可以看到 `%util` 列，它显示了每个设备的 I/O 利用率。

2. **vmstat**

    `vmstat` 可以显示关于系统虚拟内存、进程、CPU 活动等的报告。其中一部分数据涉及 I/O：

    ```bash
    vmstat 1
    ```

    这个命令每秒刷新一次输出。关于 I/O 的列有 `bi` (块输入) 和 `bo` (块输出)。

## Linux 返回值各表示什么？
在 Linux 系统中，程序或命令的返回值（也称为退出状态或退出码）用于表示程序执行的成功或失败。返回值是一个整数，按照约定，`0` 表示成功，而非 `0` 值表示失败。具体的非 `0` 值可以用来指示特定类型的错误。

以下是一些常见的返回值及其含义：

1. **0** - 成功
2. **1** - 通常表示通用或未分类的错误
3. **2** - 命令行语法错误
4. **128 + N** - 由于收到信号 `N` 导致的退出。例如，如果一个进程由于收到 `SIGKILL` （其值为9）而终止，则它将返回 `128 + 9 = 137`。
5. **130** - 由于接收到 `SIGINT` 信号而退出，通常是由于用户按下 `Ctrl+C`。

尽管有这些常见的退出代码约定，但应用程序和命令可能会返回其它任意的非零值来指示各种特定的错误或状态。

如果你想查看上一个命令的返回值，你可以使用特殊变量 `$?`。例如，在执行命令后，你可以输入 `echo $?` 来查看该命令的返回值。