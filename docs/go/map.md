# `map`
## `map` 的底层结构？
1. **哈希表**：Go 中的 `map` 是一个哈希表。哈希表是一个动态数组，其中每个元素是一个桶（bucket）。

2. **桶（Bucket）**：每个桶可以存储一定数量的键值对。在 Go 的当前实现中，每个桶可以存储最多 8 个键值对。

3. **哈希函数**：为了确定键值对在哪个桶中，`map` 使用了一个哈希函数。这个哈希函数会取键的哈希值，然后使用该哈希值的一部分来选择一个桶。

4. **溢出桶**：如果一个桶已经填满（存储了 8 对键值对）并且有新的键需要存储在那里，那么会创建一个"溢出桶"来存储额外的键值对。溢出桶是链式到原始桶的。

5. **扩容与收缩**：当 `map` 的装载因子（即已存储的键值对数与总桶数之比）超过一定阈值时，`map` 会进行扩容，即增加桶的数量并重新分配键值对。与此相反，如果 `map` 大小缩小并且装载因子降低到某个点，`map` 可能会收缩以节省空间。

6. **迭代顺序**：为了安全和随机化的目的，Go `map` 的迭代顺序是不确定的。这意味着当你使用 `range` 循环遍历 `map` 时，键值对的顺序可能会在不同的迭代中有所不同。

7. **安全性**：Go 的 `map` 在默认情况下是不安全的，意味着并发的读写会导致不确定的行为。如果你需要并发访问，应该使用互斥锁（如 `sync.Mutex`）或者使用 `sync.Map` 这种为并发设计的结构。