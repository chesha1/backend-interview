# 基础语法
## 结构体能不能比较
在 Go 语言中，结构体可以进行比较，但有一些注意事项。


1. **可比较的结构体**：如果结构体的所有字段都是可比较的，那么结构体本身也是可比较的。这意味着你可以使用 `==` 和 `!=` 运算符来比较两个结构体变量是否具有相同的值。

       ```go
       type Point struct {
           X, Y int
       }
    
       p1 := Point{1, 2}
       p2 := Point{1, 2}
       p3 := Point{2, 3}
    
       fmt.Println(p1 == p2) // 输出：true
       fmt.Println(p1 == p3) // 输出：false
       ```

2. **不可比较的结构体**：如果结构体包含不可比较的字段（例如 map 或 slice），则不能直接比较这些结构体。尝试这样做会在编译时导致错误。

## `new` 和 `make` 的区别
在 Go 语言中，`new` 和 `make` 都是创建值的内建函数，但它们的用途和行为是有所不同的

1. **用途**：
     - `new` 用于为任何类型分配内存，并返回该类型的零值的指针。
     - `make` 用于创建 slice、map 和 channel。

2. **返回值**：
     - `new(T)` 返回一个指向类型 `T` 的新分配的零值的指针，返回的值是 `*T` 类型。
     - `make(T)` 返回一个已初始化的类型 `T` 的值，这意味着它返回的是相同的类型，不是指针。

3. **零值和初始化**：
     - `new` 分配内存并返回指向该内存的指针，这块内存被初始化为类型的零值。
     - `make` 创建一个具有非零值的值。例如，创建一个切片时，它将为切片分配底层数组并准备好切片的长度和容量。

4. **用法示例**：
       - 使用 `new`：
         ```go
         ptr := new(int)
         *ptr = 3
         ```
      - 使用 `make`：
       ```go
       slice := make([]int, 3)  // 创建一个长度为3的int切片
       mapData := make(map[string]int)  // 创建一个string到int的映射
       ch := make(chan int)  // 创建一个int类型的通道
       ```

## 切片和数组的区别
在 Go 语言中，切片（slice）和数组（array）都是处理序列数据的重要数据结构

1. **大小固定性**：
    - **数组**：当定义数组时，需要指定其大小，而且该大小在整个生命周期中是固定的。一旦数组被定义，不能更改其大小。
    - **切片**：切片的大小是动态的。你可以向切片追加元素，使其增长，但内部它是通过重新分配一个更大的底层数组来实现的。

2. **声明方式**：
    - **数组**：指定其长度。
      ```go
      var arr [5]int
      ```
    - **切片**：不指定长度。
      ```go
      var s []int
      ```

3. **长度与容量**：
    - **数组**：长度就是其声明时指定的大小。
    - **切片**：具有长度和容量两个属性。长度是切片中当前元素的数量，而容量是底层数组中的元素数量。由于切片是引用底层数组的，所以其容量可能大于其长度。

4. **底层实现**：
    - **数组**：是一个连续的内存块，由固定数目的元素组成。
    - **切片**：是一个引用类型，它有三个关键属性：指向底层数组的指针、长度和容量。

5. **函数参数传递**：
    - **数组**：作为函数参数传递时，是值传递，函数内对数组的修改不会影响原数组。
    - **切片**：作为函数参数传递时，是引用传递。函数内对切片的修改会影响原切片。

## 切片是如何扩容的？
1. **扩容触发**：当你使用 `append` 向切片添加元素，并且切片的当前容量不足以容纳新的元素时，扩容会被触发。

2. **扩容策略**：

      - 对于容量小于 256 的切片，新容量通常是当前容量的两倍。
   
      - 对于容量大于或等于 256 的切片，$\rm{newcap = oldcap+(oldcap+3 \times 256)/4}$

      - 但是，考虑到内存对齐，新容量会比上面的公式计算出来的容量更大

      - 以上是 Go 1.18 及其之后版本的扩容策略，在旧版本中，扩容阈值和增长因子会有变化

3. **扩容实现**：创建一个新的底层数组、复制旧的数据，然后更新切片的引用以指向新数组。无其他引用的旧底层数组将被垃圾收集。

4. **关于底层数组的共享**：当从一个切片创建另一个切片时，它们可能会共享同一个底层数组。因此，在扩容之前，对其中一个切片的修改可能会影响到另一个切片。但一旦触发扩容，切片将引用一个新的底层数组，此时原切片和新切片就不再共享数据了。
