# 算法
## 讲讲快速排序的原理？
快速排序（Quick Sort）是由 Tony Hoare 在1960年代初期发明的一种排序算法。它是一种高效、就地、不稳定的比较排序算法。

快速排序的基本思想很简单：选择数组中的一个元素作为“基准”（pivot），然后将数组分为两个子数组，一个包含小于基准的元素，另一个包含大于基准的元素。这个分区操作是线性时间的，且可以原地完成。然后，算法递归地排序这两个子数组。

快速排序的性能取决于选择的基准元素。在最理想的情况下，选择的基准恰好将数组分成两个相等的部分，使得快速排序的性能最大化。这导致一个 \( O(n \log n) \) 的平均时间复杂度。但在最坏的情况下，例如当输入数组已经排序，并且我们总是选择第一个或最后一个元素作为基准，快速排序的时间复杂度会退化到 \(O(n^2)\)。

为了防止最坏情况的发生，实际的快速排序实现通常使用了一些策略，例如随机选择基准，或者使用“三分中值”策略（从数组的首部、中部、尾部选择三个元素，并使用它们的中值作为基准）。

尽管在最坏的情况下快速排序可能不是最佳的，但由于它的平均性能非常好并且有较好的缓存性能，它通常比其他 \(O(n \log n)\) 算法（如归并排序和堆排序）更快。

## 快排时间复杂度是多少？为什么？
为了证明快速排序的平均时间复杂度为 \( \Theta(n \log n) \)，我们需要考虑所有可能的基准元素的选择。证明的核心思想是利用随机选择的基准元素将数组均匀地分成两部分。

以下是简化的证明步骤：

1. **分区的期望时间**：

    我们考虑对大小为 \( n \) 的数组进行分区。无论如何选择基准，分区操作都是线性的，所以它的时间复杂度是 \( O(n) \)。

2. **递归的期望次数**：

    我们想要求的是，如果我们随机选择基准，那么递归调用的期望深度是多少。考虑最好的情况，我们每次都均匀地将数组分为两半，那么深度是 \( \log n \)。而最坏的情况是我们每次选择最小或最大的元素为基准，导致深度为 \( n \)。

    但是，随机选择基准意味着我们有相同的概率选择任何元素。因此，我们不太可能总是选择最差的基准。事实上，有相当大的概率选择将数组分为至少 \( 1/4 \) 到 \( 3/4 \) 的基准。这意味着，在平均情况下，我们的递归深度接近 \( \log n \)。

3. **结合上述结果**：

    考虑快速排序的递归树，每层的工作量是 \( O(n) \)，并且期望的层数为 \( O(\log n) \)。因此，平均情况下的总工作量是 \( O(n \log n) \)。

这是一个简化的证明，并且省略了一些细节和数学推导，但它提供了快速排序平均时间复杂度为 \( \Theta(n \log n) \) 的直观理由。  

详细的证明需要用到主定理，分析递归算法的时间复杂度。

